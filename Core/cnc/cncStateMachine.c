/*$file${../cnc_muc/Core/~::cncStateMachine.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: model.qm
* File:  ${../cnc_muc/Core/~::cncStateMachine.c}
*
* This code has been generated by QM 5.2.1 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${../cnc_muc/Core/~::cncStateMachine.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^*/

#include "main.h"
#include "stdio.h"
#include "string.h"
#include "cmsis_os.h"
#include "task.h"
#include "serialDebug.h"

#include "cnc.h"
#include "cncStateMachine.h"
#include "cncInsHandler.h"
#include "qpc.h"


#define EXIT_STOP(m) return exitToStop(me, m)
#define EXIT_ERR(m) return exitToERR(me, m)
#define EXIT_ERR_STITCH(m) return exitToERRstitch(me, m)
#define EXIT_IDLE(m) return exitToIdle(me, m)

extern UART_HandleTypeDef huart2;

uint8_t failQueueCnt = 0;
uint32_t gpCount = 0;


const QEvt testDoneEvt = {.sig = TEST_DONE_SIG,};
const QEvt nextStateEvt = {.sig = NEXT_STATE_SIG,};
const QEvt stateYieldEvt = {.sig = STATE_YIELD_SIG,};
const QEvt stateTestEvt = {.sig = STATE_TEST_SIG,};
const QEvt qInitEvt = {.sig = Q_INIT_SIG,};
QEvt gpEvt = {.sig = Q_INIT_SIG,};

cncInsUn_t ins, insTemp, zeroIns;

void postTestDone();
void Q_onAssert(char const * const module, int loc){}




cncState cncStateMachine;
QEvt const * eventBuffer[10];
StaticQueue_t queuBlk;



static uint32_t threadStackBuf[512];

static QState exitToERRstitch(cncState * const me, const char *msg)
{
    if (msg != 0)
    {
        printF("ERROR_ST:%s\n", msg);
    }
    return Q_TRAN(&cncState_errorExitStitch);
}

static QState exitToERR(cncState * const me, const char *msg)
{
    if (msg != 0)
    {
        printF("ERROR:%s\n", msg);
    }
    return Q_TRAN(&cncState_errorState);
}


static QState exitToStop(cncState * const me, const char *msg)
{
    if (msg != 0)
    {
        printF("STOP:%s\n", msg);
    }
    return Q_TRAN(&cncState_stopingState);
}

static QState exitToIdle(cncState * const me, const char *msg)
{
    if (msg != 0)
    {
        printF("IDLE:%s\n", msg);
    }
    return Q_TRAN(&cncState_idle);
}


static QState gotoNextInsState(cncState * const me)
{
    QState status_;

    uint8_t stSig = readQuiltCommand();
    if (!stSig)
    {
        EXIT_STOP(0);
    }

    if (peakNextIns(&insTemp))
    {
        switch(insTemp.type)
        {
            case ZERO_INS:
            status_ = Q_TRAN(&cncState_ntop);
            break;
            case STITCH_INS:
            status_ = Q_TRAN(&cncState_ntop);
            break;
            case JUMP_INS:
            status_ = Q_TRAN(&cncState_jump);
            break;
            case SET_VALVE_INS:
            status_ = Q_TRAN(&cncState_valve);
            break;
            case STOP_INS:
            getNextIns(&insTemp);
            status_ = Q_TRAN(&cncState_idle);
            unlatchQuiltSig();
            print("sheduled output complete\n");
            default:
            status_ = Q_TRAN(&cncState_idle);
            print("invalid ins Type\n");
            break;
        }
    }
    else
    {
        status_ = Q_TRAN(&cncState_idle);
        print("no ins found in feeder\n");
    }

    return status_;

}




void postTestDone()
{
    QActive_post_(&cncStateMachine.super, &testDoneEvt, QF_NO_MARGIN, 0);
}

void postStateYield()
{
    QActive_post_(&cncStateMachine.super, &stateYieldEvt, QF_NO_MARGIN, 0);
}

void postQ_Init()
{
    QActive_post_(&cncStateMachine.super, &qInitEvt, QF_NO_MARGIN, 0);
}

void postStateTest()
{
    QActive_post_(&cncStateMachine.super, &stateTestEvt, QF_NO_MARGIN, 0);
}

void postEvent(const void *ev)
{
    QActive_post_(&cncStateMachine.super, ev, QF_NO_MARGIN, 0);
}



void postEventISR(const void *ev)
{
    QActive_postFromISR_(&cncStateMachine.super, ev, QF_NO_MARGIN, 0, 0);
}



void startStateMachine()
{

    QActive_ctor(&cncStateMachine.super, Q_STATE_CAST(&cncState_initial));
    QActive_start_(&cncStateMachine.super, osPriorityNormal, &eventBuffer, Q_DIM(eventBuffer), threadStackBuf, 512, 0);
}


/*================ ask QM to define the Blinky class ================*/
/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${CNC::cncState} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${CNC::cncState} .........................................................*/

/*${CNC::cncState::SM} .....................................................*/
QState cncState_initial(cncState * const me, void const * const par) {
    /*${CNC::cncState::SM::initial} */
    return Q_TRAN(&cncState_idle);
}

/*${CNC::cncState::SM::idle} ...............................................*/
QState cncState_idle(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::idle} */
        case Q_ENTRY_SIG: {
            print("idle\n");
            stopFeederv2();
            enterIdleState();
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::SET_NEEDLE_TOP_POS} */
        case SET_NEEDLE_TOP_POS_SIG: {
            status_ = Q_TRAN(&cncState_needleTop);
            break;
        }
        /*${CNC::cncState::SM::idle::SET_LOOP_POS} */
        case SET_LOOP_POS_SIG: {
            status_ = Q_TRAN(&cncState_needleLoop);
            break;
        }
        /*${CNC::cncState::SM::idle::SENSOR_TOP} */
        case SENSOR_TOP_SIG: {
            print("SENSOR_TOP\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::SENSOR_CLT_OUT} */
        case SENSOR_CLT_OUT_SIG: {
            print("SENSOR_CLT_OUT\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::SENSOR_ZERO} */
        case SENSOR_ZERO_SIG: {
            print("SENSOR_ZERO\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::TEST_DONE} */
        case TEST_DONE_SIG: {
            print("TEST_DONE\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::STOP} */
        case STOP_SIG: {
            print("stop sig\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::TEST_SERVO} */
        case TEST_SERVO_SIG: {
            machineTestEvt_t *ev = (machineTestEvt_t*)e;
            /*${CNC::cncState::SM::idle::TEST_SERVO::[isNeedleOnTop()]} */
            if (isNeedleOnTop()) {
                print("moveX form state");
                /*${CNC::cncState::SM::idle::TEST_SERVO::[isNeedleOnTop()~::[ev->testType=='x']} */
                if (ev->testType == 'x') {
                    moveServo(ev->steps.stepCount, 0, ev->steps.stepTime, 1);
                    status_ = Q_TRAN(&cncState_testServo);
                }
                /*${CNC::cncState::SM::idle::TEST_SERVO::[isNeedleOnTop()~::[ev->testType=='y']} */
                else if (ev->testType == 'y') {
                    moveServo(0, ev->steps.stepCount, ev->steps.stepTime, 1);
                    status_ = Q_TRAN(&cncState_testServo);
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::idle::SET_BREAK_COM} */
        case SET_BREAK_COM_SIG: {
            RsetBreak();
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::RESET_BREAK_COM} */
        case RESET_BREAK_COM_SIG: {
            RresetBreak();
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::SET_VALVE_COM} */
        case SET_VALVE_COM_SIG: {
            machineTestEvt_t *ev = (machineTestEvt_t*)e;
            setValve(ev->valve);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::RESET_VALVE_COM} */
        case RESET_VALVE_COM_SIG: {
            machineTestEvt_t *ev = (machineTestEvt_t*)e;
            resetValve(ev->valve);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::START} */
        case START_SIG: {
            uint8_t quilt = readQuiltSig();
            /*${CNC::cncState::SM::idle::START::[quilt]} */
            if (quilt) {
                exitIdleState();
                status_ = Q_TRAN(&cncState_halt);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::idle::HELPER_EVENT} */
        case HELPER_EVENT_SIG: {
            print("helper event\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::HELPER_PAUSE} */
        case HELPER_PAUSE_SIG: {
            print("helper pause\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::SENSOR_DOWN} */
        case SENSOR_DOWN_SIG: {
            print("SENSOR_DOWN\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::SET_NEEDLE_DOWN_POS} */
        case SET_NEEDLE_DOWN_POS_SIG: {
            status_ = Q_TRAN(&cncState_needleDown);
            break;
        }
        /*${CNC::cncState::SM::idle::IO_TEST_MODE} */
        case IO_TEST_MODE_SIG: {
            status_ = Q_TRAN(&cncState_ioTestMode);
            break;
        }
        /*${CNC::cncState::SM::idle::TOGGLE_BREAK_COM} */
        case TOGGLE_BREAK_COM_SIG: {
            RtoggleBreak();
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::MOVE_SEROV} */
        case MOVE_SEROV_SIG: {
            /*${CNC::cncState::SM::idle::MOVE_SEROV::[isNeedleOnTop()]} */
            if (isNeedleOnTop()) {
                RsetBreak();
                status_ = Q_TRAN(&cncState_moveServo);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::idle::SIM_START} */
        case SIM_START_SIG: {
            print("SIM_START_SIG\n");
            status_ = Q_TRAN(&cncState_SIM_run);
            break;
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::idle::SIM_STOP} */
        case SIM_STOP_SIG: {
            print("SIM_STOP_SIG\n");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::needleTop} ..........................................*/
QState cncState_needleTop(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::needleTop} */
        case Q_ENTRY_SIG: {
            print("needleTop\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::needleTop::SENSOR_TOP,TEST_DONE} */
        case SENSOR_TOP_SIG: /* intentionally fall through */
        case TEST_DONE_SIG: {
            RsetBreak();
            postTestDone();
            disArmTimer();
            status_ = Q_TRAN(&cncState_idle);
            break;
        }
        /*${CNC::cncState::SM::needleTop::Q_INIT} */
        case Q_INIT_SIG: {
            if (isNeedleOnTop())
            {
                postTestDone();
            }
            else
            {
                RresetBreak();
                osDelay(100);
                startVfd(1);
                armTimer(2000, &stateYieldEvt);

            }
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::needleTop::SENSOR_CLT_OUT,SENSOR_ZERO,SENSO~} */
        case SENSOR_CLT_OUT_SIG: /* intentionally fall through */
        case SENSOR_ZERO_SIG: /* intentionally fall through */
        case SENSOR_DOWN_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::needleTop::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            startVfd(0);
            status_ = Q_TRAN(&cncState_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::needleLoop} .........................................*/
QState cncState_needleLoop(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::needleLoop} */
        case Q_ENTRY_SIG: {
            print("needleClOut\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::needleLoop::Q_INIT} */
        case Q_INIT_SIG: {
            RresetBreak();
            osDelay(100);
            startVfd(1);
            gpCount = 0;

            armTimer(2000, &stateYieldEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::needleLoop::SENSOR_CLT_OUT} */
        case SENSOR_CLT_OUT_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::needleLoop::SENSOR_TOP} */
        case SENSOR_TOP_SIG: {
            /*${CNC::cncState::SM::needleLoop::SENSOR_TOP::[gpCount>=1]} */
            if (gpCount >= 1) {
                RsetBreak();
                disArmTimer();
                status_ = Q_TRAN(&cncState_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::needleLoop::SENSOR_DOWN} */
        case SENSOR_DOWN_SIG: {
            gpCount++;
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::needleLoop::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            startVfd(0);
            status_ = Q_TRAN(&cncState_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::testServo} ..........................................*/
QState cncState_testServo(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::testServo::X_SERVO_PAUSE, Y_SERVO_PAUSE} */
        case X_SERVO_PAUSE_SIG: /* intentionally fall through */
        case Y_SERVO_PAUSE_SIG: {
            /*${CNC::cncState::SM::testServo::X_SERVO_PAUSE, Y~::[!(TIM3->CR1&TIM_CR1_CEN)&&!(TIM~} */
            if (!(TIM3->CR1 & TIM_CR1_CEN) && !(TIM4->CR1 & TIM_CR1_CEN)) {
                status_ = Q_TRAN(&cncState_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::zero} ...............................................*/
QState cncState_zero(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::zero} */
        case Q_ENTRY_SIG: {
            print("zero ins\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::zero::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            EXIT_ERR_STITCH("peak fail in ZERO\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::zero::Q_INIT} */
        case Q_INIT_SIG: {
            cncInsUn_t tIns;
            int peak = peakNextIns(&tIns);
            /*${CNC::cncState::SM::zero::Q_INIT::[peak]} */
            if (peak) {
                /*${CNC::cncState::SM::zero::Q_INIT::[peak]::[tIns.type==ZERO_INS]} */
                if (tIns.type == ZERO_INS) {
                    getNextIns(&zeroIns);
                    status_ = Q_TRAN(&cncState_zeroRunning);
                }
                /*${CNC::cncState::SM::zero::Q_INIT::[peak]::[tIns.type!=ZERO_INS]} */
                else if (tIns.type != ZERO_INS
)
                {
                    postStateYield();
                    status_ = Q_HANDLED();
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::zero::Q_INIT::[!peak]} */
            else if (!peak) {
                postStateYield();
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::zero::zeroRunning} ..................................*/
QState cncState_zeroRunning(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::zero::zeroRunning::SENSOR_CLT_OUT} */
        case SENSOR_CLT_OUT_SIG: {
            if (!servoTrigger())
                EXIT_ERR("fail to triger servo from ZERO\n");


            uint8_t zSig = isXonZero();
            uint8_t stSig = readQuiltCommand();
            /*${CNC::cncState::SM::zero::zeroRunning::SENSOR_CLT_OUT::[!zSig]} */
            if (!zSig) {
                /*${CNC::cncState::SM::zero::zeroRunning::SENSOR_CLT_OUT::[!zSig]::[stSig]} */
                if (stSig) {
                    makeStitch(&zeroIns.stitchIns);
                    status_ = Q_HANDLED();
                }
                /*${CNC::cncState::SM::zero::zeroRunning::SENSOR_CLT_OUT::[!zSig]::[!stSig]} */
                else if (!stSig) {
                    status_ = Q_TRAN(&cncState_zeroStoping);
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::zero::zeroRunning::SENSOR_CLT_OUT::[zSig]} */
            else if (zSig) {
                uint8_t peak = peakNextIns(&insTemp);
                /*${CNC::cncState::SM::zero::zeroRunning::SENSOR_CLT_OUT::[zSig]::[peak]} */
                if (peak) {
                    /*${CNC::cncState::SM::zero::zeroRunning::SENSOR_CLT_OUT::[zSig]::[peak]::[insTemp.type==STITCH_INS]} */
                    if (insTemp.type == STITCH_INS) {
                        status_ = Q_TRAN(&cncState_stitchRunning);
                    }
                    /*${CNC::cncState::SM::zero::zeroRunning::SENSOR_CLT_OUT::[zSig]::[peak]::[insTemp.type!=STITCH_INS]} */
                    else if (insTemp.type != STITCH_INS) {
                        status_ = Q_TRAN(&cncState_zeroChangeOver);
                    }
                    else {
                        status_ = Q_UNHANDLED();
                    }
                }
                /*${CNC::cncState::SM::zero::zeroRunning::SENSOR_CLT_OUT::[zSig]::[!peak]} */
                else if (!peak) {

                    EXIT_ERR_STITCH("peak fail in ZERO\n");
                    status_ = Q_HANDLED();
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::zero::zeroRunning::Q_INIT} */
        case Q_INIT_SIG: {
            makeStitch(&zeroIns.stitchIns);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::zero::zeroRunning::RESET_BREAK} */
        case RESET_BREAK_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_zero);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::zero::zeroStoping} ..................................*/
QState cncState_zeroStoping(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT} */
        case SENSOR_CLT_OUT_SIG: {
            if (!servoTrigger())
                EXIT_ERR("fail to triger servo from ZERO\n");

            print("stop clout stitch ");
            uint8_t zSig = isXonZero();
            uint8_t stSig = readQuiltCommand();
            /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[!zSig]} */
            if (!zSig) {
                /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[!zSig]::[!stSig]} */
                if (!stSig) {
                    uint8_t stopStep = getStopingSteps();
                    /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[!zSig]::[!stSig]::[stopStep>=4]} */
                    if (stopStep >= 4) {
                        status_ = Q_TRAN(&cncState_zeroLastStitch);
                    }
                    /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[!zSig]::[!stSig]::[stopStep<4]} */
                    else if (stopStep < 4) {
                        cncInsUn_t tIns;
                        tIns = zeroIns;
                        tIns.zeroIns.vfdSpeed = 'S';
                        print("stop stitch ");
                        makeStitch(&tIns.stitchIns);
                        status_ = Q_HANDLED();
                    }
                    else {
                        status_ = Q_UNHANDLED();
                    }
                }
                /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[!zSig]::[stSig]} */
                else if (stSig) {
                    status_ = Q_TRAN(&cncState_zeroRunning);
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[zSig]} */
            else if (zSig) {
                uint8_t peak = peakNextIns(&insTemp);
                /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[zSig]::[peak]} */
                if (peak) {
                    /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[zSig]::[peak]::[insTemp.type==STITCH_INS]} */
                    if (insTemp.type == STITCH_INS) {
                        status_ = Q_TRAN(&cncState_stitchStoping);
                    }
                    /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[zSig]::[peak]::[insTemp.type!=STITCH_INS]} */
                    else if (insTemp.type != STITCH_INS) {
                        status_ = Q_TRAN(&cncState_zeroChangeOver);
                    }
                    else {
                        status_ = Q_UNHANDLED();
                    }
                }
                /*${CNC::cncState::SM::zero::zeroStoping::SENSOR_CLT_OUT::[zSig]::[!peak]} */
                else if (!peak) {

                    EXIT_ERR_STITCH("peak fail in ZERO\n");
                    status_ = Q_HANDLED();
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::zero::zeroStoping::Q_INIT} */
        case Q_INIT_SIG: {
            cncInsUn_t tIns;
            tIns = zeroIns;
            tIns.zeroIns.vfdSpeed = 'S';
            print("stop stitch ");
            makeStitch(&tIns.stitchIns);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_zero);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::zero::zeroLastStitch} ...............................*/
QState cncState_zeroLastStitch(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::zero::zeroLastStitch::SENSOR_TOP} */
        case SENSOR_TOP_SIG: {
            setBreak();
            /*${CNC::cncState::SM::zero::zeroLastStitch::SENSOR_TOP::[!(TIM3->CR1&TIM_CR1_CEN)&&!(TIM~} */
            if (!(TIM3->CR1 & TIM_CR1_CEN) && !(TIM4->CR1 & TIM_CR1_CEN) && isBreakSet()) {
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::zero::zeroLastStitch::X_SERVO_PAUSE, Y_SERVO_PAUSE} */
        case X_SERVO_PAUSE_SIG: /* intentionally fall through */
        case Y_SERVO_PAUSE_SIG: {
            /*${CNC::cncState::SM::zero::zeroLastStitch::X_SERVO_PAUSE, Y~::[!(TIM3->CR1&TIM_CR1_CEN)&&!(TIM~} */
            if (!(TIM3->CR1 & TIM_CR1_CEN) && !(TIM4->CR1 & TIM_CR1_CEN) && isBreakSet()) {
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_zero);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::zero::zeroChangeOver} ...............................*/
QState cncState_zeroChangeOver(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::zero::zeroChangeOver::SENSOR_TOP} */
        case SENSOR_TOP_SIG: {
            setBreak();
            /*${CNC::cncState::SM::zero::zeroChangeOver::SENSOR_TOP::[!(TIM3->CR1&TIM_CR1_CEN)&&!(TIM~} */
            if (!(TIM3->CR1 & TIM_CR1_CEN) && !(TIM4->CR1 & TIM_CR1_CEN) && isBreakSet()) {
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::zero::zeroChangeOver::X_SERVO_PAUSE, Y_SERVO_PAUSE} */
        case X_SERVO_PAUSE_SIG: /* intentionally fall through */
        case Y_SERVO_PAUSE_SIG: {
            /*${CNC::cncState::SM::zero::zeroChangeOver::X_SERVO_PAUSE, Y~::[!(TIM3->CR1&TIM_CR1_CEN)&&!(TIM~} */
            if (!(TIM3->CR1 & TIM_CR1_CEN) && !(TIM4->CR1 & TIM_CR1_CEN) && isBreakSet()) {
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_zero);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::stitch} .............................................*/
QState cncState_stitch(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::stitch} */
        case Q_ENTRY_SIG: {
            print("stitch ins\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::stitch::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&cncState_stitchRunning);
            break;
        }
        /*${CNC::cncState::SM::stitch::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            EXIT_ERR_STITCH("peak fail in STITCH\n");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::stitch::stitchRunning} ..............................*/
QState cncState_stitchRunning(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::stitch::stitchRunning::SENSOR_CLT_OUT} */
        case SENSOR_CLT_OUT_SIG: {
            if (!servoTrigger())
                EXIT_ERR("fail to triger servo from STITCH\n");

            uint8_t peak = peakNextIns(&insTemp);
            uint8_t stSig = readQuiltCommand();
            /*${CNC::cncState::SM::stitch::stitchRunning::SENSOR_CLT_OUT::[peak]} */
            if (peak) {
                /*${CNC::cncState::SM::stitch::stitchRunning::SENSOR_CLT_OUT::[peak]::[insTemp.type==STITCH_INS]} */
                if (insTemp.type == STITCH_INS) {
                    /*${CNC::cncState::SM::stitch::stitchRunning::SENSOR_CLT_OUT::[peak]::[insTemp.type==S~::[stSig]} */
                    if (stSig) {
                        cncInsUn_t tIns;
                        getNextIns(&tIns);
                        makeStitch(&tIns.stitchIns);
                        status_ = Q_HANDLED();
                    }
                    /*${CNC::cncState::SM::stitch::stitchRunning::SENSOR_CLT_OUT::[peak]::[insTemp.type==S~::[!stSig]} */
                    else if (!stSig) {
                        status_ = Q_TRAN(&cncState_stitchStoping);
                    }
                    else {
                        status_ = Q_UNHANDLED();
                    }
                }
                /*${CNC::cncState::SM::stitch::stitchRunning::SENSOR_CLT_OUT::[peak]::[insTemp.type==ZERO_INS]} */
                else if (insTemp.type == ZERO_INS) {
                    status_ = Q_TRAN(&cncState_zeroRunning);
                }
                /*${CNC::cncState::SM::stitch::stitchRunning::SENSOR_CLT_OUT::[peak]::[insTemp.type!=STITCH_INS]} */
                else if (insTemp.type != STITCH_INS) {
                    status_ = Q_TRAN(&cncState_stitchChangeOver);
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::stitch::stitchRunning::SENSOR_CLT_OUT::[!peak]} */
            else if (!peak) {

                EXIT_ERR_STITCH("peak fail in STITCH\n");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::stitch::stitchRunning::Q_INIT} */
        case Q_INIT_SIG: {
            cncInsUn_t tIns;
            int peak = peakNextIns(&tIns);

            /*${CNC::cncState::SM::stitch::stitchRunning::Q_INIT::[peak]} */
            if (peak) {
                /*${CNC::cncState::SM::stitch::stitchRunning::Q_INIT::[peak]::[tIns.type==STITCH_INS]} */
                if (tIns.type == STITCH_INS) {
                    getNextIns(&tIns);
                    makeStitch(&tIns.stitchIns);
                    status_ = Q_HANDLED();
                }
                /*${CNC::cncState::SM::stitch::stitchRunning::Q_INIT::[peak]::[tIns.type!=STITCH_INS]} */
                else if (tIns.type != STITCH_INS) {
                    startVfd(1);
                    postStateYield();
                    status_ = Q_HANDLED();
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::stitch::stitchRunning::Q_INIT::[!peak]} */
            else if (!peak) {

                postStateYield();
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_stitch);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::stitch::lastStitch} .................................*/
QState cncState_lastStitch(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::stitch::lastStitch} */
        case Q_ENTRY_SIG: {
            print("last stitch\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::stitch::lastStitch::X_SERVO_PAUSE, Y_SERVO_PAUSE} */
        case X_SERVO_PAUSE_SIG: /* intentionally fall through */
        case Y_SERVO_PAUSE_SIG: {
            /*${CNC::cncState::SM::stitch::lastStitch::X_SERVO_PAUSE, Y~::[xServoPaused()&&yServoPaused()&~} */
            if (xServoPaused() && yServoPaused() && isBreakSet()) {
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::stitch::lastStitch::SENSOR_TOP} */
        case SENSOR_TOP_SIG: {
            setBreak();
            /*${CNC::cncState::SM::stitch::lastStitch::SENSOR_TOP::[xServoPaused()&&yServoPaused()&~} */
            if (xServoPaused() && yServoPaused() && isBreakSet()) {
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_stitch);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::stitch::stitchStoping} ..............................*/
QState cncState_stitchStoping(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::stitch::stitchStoping::Q_INIT} */
        case Q_INIT_SIG: {
            stitchIns_t tIns;
            getNextIns(&tIns);
            makeStitch(&tIns);
            print("stop stitch state\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::stitch::stitchStoping::SENSOR_CLT_OUT} */
        case SENSOR_CLT_OUT_SIG: {
            if (!servoTrigger())
                EXIT_ERR("fail to triger servo from STITCH\n");

            uint8_t peak = peakNextIns(&insTemp);
            uint8_t zSig = isXonZero();
            uint8_t stSig = readQuiltCommand();


            /*${CNC::cncState::SM::stitch::stitchStoping::SENSOR_CLT_OUT::[peak]} */
            if (peak) {
                /*${CNC::cncState::SM::stitch::stitchStoping::SENSOR_CLT_OUT::[peak]::[insTemp.type==STITCH_INS]} */
                if (insTemp.type == STITCH_INS) {
                    /*${CNC::cncState::SM::stitch::stitchStoping::SENSOR_CLT_OUT::[peak]::[insTemp.type==S~::[!stSig]} */
                    if (!stSig) {
                        uint8_t stopStep = getStopingSteps();
                        /*${CNC::cncState::SM::stitch::stitchStoping::SENSOR_CLT_OUT::[peak]::[insTemp.type==S~::[!stSig]::[stopStep>=4]} */
                        if (stopStep >= 4) {
                            status_ = Q_TRAN(&cncState_lastStitch);
                        }
                        /*${CNC::cncState::SM::stitch::stitchStoping::SENSOR_CLT_OUT::[peak]::[insTemp.type==S~::[!stSig]::[stopStep<4]} */
                        else if (stopStep < 4) {
                            cncInsUn_t tIns;
                            getNextIns(&tIns);
                            tIns.stitchIns.vfdSpeed = 'S';
                            makeStitch(&tIns.stitchIns);
                            status_ = Q_HANDLED();
                        }
                        else {
                            status_ = Q_UNHANDLED();
                        }
                    }
                    /*${CNC::cncState::SM::stitch::stitchStoping::SENSOR_CLT_OUT::[peak]::[insTemp.type==S~::[stSig]} */
                    else if (stSig) {
                        status_ = Q_TRAN(&cncState_stitchRunning);
                    }
                    else {
                        status_ = Q_UNHANDLED();
                    }
                }
                /*${CNC::cncState::SM::stitch::stitchStoping::SENSOR_CLT_OUT::[peak]::[insTemp.type!=STITCH_INS]} */
                else if (insTemp.type != STITCH_INS) {
                    status_ = Q_TRAN(&cncState_lastStitch);
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::stitch::stitchStoping::SENSOR_CLT_OUT::[!peak]} */
            else if (!peak) {

                EXIT_ERR_STITCH("peak fail in STITCH\n");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_stitch);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::stitch::stitchChangeOver} ...........................*/
QState cncState_stitchChangeOver(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::stitch::stitchChangeOver::SENSOR_TOP} */
        case SENSOR_TOP_SIG: {
            setBreak();
            /*${CNC::cncState::SM::stitch::stitchChangeOver::SENSOR_TOP::[xServoPaused()&&yServoPaused()&~} */
            if (xServoPaused() && yServoPaused() && isBreakSet()) {
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::stitch::stitchChangeOver::X_SERVO_PAUSE, Y_SERVO_PAUSE} */
        case X_SERVO_PAUSE_SIG: /* intentionally fall through */
        case Y_SERVO_PAUSE_SIG: {
            /*${CNC::cncState::SM::stitch::stitchChangeOver::X_SERVO_PAUSE, Y~::[xServoPaused()&&yServoPaused()&~} */
            if (xServoPaused() && yServoPaused() && isBreakSet()) {
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_stitch);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::valve} ..............................................*/
QState cncState_valve(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::valve} */
        case Q_ENTRY_SIG: {
            print("valve ins\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::valve::Q_INIT} */
        case Q_INIT_SIG: {
            cncInsUn_t tIns;
            uint8_t peak = peakNextIns(&tIns);
            /*${CNC::cncState::SM::valve::Q_INIT::[peak]} */
            if (peak) {
                /*${CNC::cncState::SM::valve::Q_INIT::[peak]::[tIns.type==SET_VALVE_INS]} */
                if (tIns.type == SET_VALVE_INS) {
                    getNextIns(&tIns);
                    writeValves(tIns.valveIns.valve);

                    /*${CNC::cncState::SM::valve::Q_INIT::[peak]::[tIns.type==SET_~::[tIns.valveIns.delay>0]} */
                    if (tIns.valveIns.delay > 0) {
                        armTimer(tIns.valveIns.delay, (void*)&nextStateEvt);
                        status_ = Q_HANDLED();
                    }
                    /*${CNC::cncState::SM::valve::Q_INIT::[peak]::[tIns.type==SET_~::[tIns.valveIns.delay==0]} */
                    else if (tIns.valveIns.delay == 0) {
                        postEvent(&nextStateEvt);
                        status_ = Q_HANDLED();
                    }
                    else {
                        status_ = Q_UNHANDLED();
                    }
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::valve::Q_INIT::[!peak]} */
            else if (!peak) {
                writeValves(0);
                postStateYield();
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::valve::NEXT_STATE} */
        case NEXT_STATE_SIG: {
            return gotoNextInsState(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::valve::STOP} */
        case STOP_SIG: {
            disArmTimer();
            writeValves(0);
            return gotoNextInsState(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::valve::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            EXIT_ERR("peak fail in VALVE\n");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::halt} ...............................................*/
QState cncState_halt(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::halt::STOP} */
        case STOP_SIG: {
            disArmTimer();
            uint8_t stop = !readQuiltSig();

            /*${CNC::cncState::SM::halt::STOP::[stop]} */
            if (stop) {
                status_ = Q_TRAN(&cncState_idle);
            }
            /*${CNC::cncState::SM::halt::STOP::[!stop]} */
            else if (!stop) {
                print("improper STOP_SIG\n");
                status_ = Q_TRAN(&cncState_errorState);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::halt::Q_INIT} */
        case Q_INIT_SIG: {
            runFeeder();
            armTimer(2000, &stateYieldEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::halt::QUILT_RUN} */
        case QUILT_RUN_SIG: {
            disArmTimer();
            int space = getQueueSpace();
            int command = readQuiltCommand();
            int run = 0;
            if (space <= 4 && command)
            {
            run = 1;
            }
            /*${CNC::cncState::SM::halt::QUILT_RUN::[run]} */
            if (run) {
                status_ = Q_TRAN(&cncState_ntop);
            }
            /*${CNC::cncState::SM::halt::QUILT_RUN::[!run]} */
            else if (!run) {
                print("fail to run FEEDER\n");
                status_ = Q_TRAN(&cncState_errorState);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::halt::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            print("timeout for QULT_RUN_SIG\n");
            status_ = Q_TRAN(&cncState_errorState);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::jump} ...............................................*/
QState cncState_jump(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::jump} */
        case Q_ENTRY_SIG: {
            print("jump ready\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::jump::Q_INIT} */
        case Q_INIT_SIG: {
            uint8_t i, end = 0;
            for (i = 0; i < 3; i++)
            {
                if (peakNextIns(&insTemp))
                {
                    if (insTemp.type == JUMP_INS)
                    {
                        getNextIns(&insTemp);
                        makeJump(&insTemp.jumpIns);
                    }
                    else
                    {
                        end = 1;
                        terminateJump();
                        armTimer(1000, (void*)&stateYieldEvt);
                        break;
                    }
                }
                else if (i == 0)
                    return Q_TRAN(&cncState_idle);
                else
                {
                    end = 1;
                    terminateJump();
                    armTimer(1000, (void*)&stateYieldEvt);
                    break;
                }

            }

            /*${CNC::cncState::SM::jump::Q_INIT::[!end]} */
            if (!end) {
                armTimer(1000, (void*)&nextStateEvt);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::jump::NEXT_STATE} */
        case NEXT_STATE_SIG: {
            print("helperTrigger\n");
            helperTigger();

            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::jump::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            print("!state yeild\n");
            helperTigger();

            status_ = Q_TRAN(&cncState_jumpEnd);
            break;
        }
        /*${CNC::cncState::SM::jump::HELPER_EVENT} */
        case HELPER_EVENT_SIG: {
            uint8_t peak = peakNextIns(&insTemp);
            /*${CNC::cncState::SM::jump::HELPER_EVENT::[peak]} */
            if (peak) {
                /*${CNC::cncState::SM::jump::HELPER_EVENT::[peak]::[insTemp.type==JUMP_INS]} */
                if (insTemp.type == JUMP_INS) {
                    uint8_t stSig = readQuiltCommand();
                    /*${CNC::cncState::SM::jump::HELPER_EVENT::[peak]::[insTemp.type==J~::[!stSig]} */
                    if (!stSig) {
                        terminateJump();
                        print("!sig\n");
                        status_ = Q_TRAN(&cncState_jumpEnd);
                    }
                    /*${CNC::cncState::SM::jump::HELPER_EVENT::[peak]::[insTemp.type==J~::[stSig]} */
                    else if (stSig) {
                        getNextIns(&insTemp);
                        makeJump(&insTemp.jumpIns);
                        status_ = Q_HANDLED();
                    }
                    else {
                        status_ = Q_UNHANDLED();
                    }
                }
                /*${CNC::cncState::SM::jump::HELPER_EVENT::[peak]::[insTemp.type!=JUMP_INS]} */
                else if (insTemp.type != JUMP_INS) {
                    terminateJump();
                    print("ins != \n");
                    status_ = Q_TRAN(&cncState_jumpEnd);
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::jump::HELPER_EVENT::[!peak]} */
            else if (!peak) {
                terminateJump();
                EXIT_ERR("peak fail in VALVE\n");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::jump::jumpEnd} ......................................*/
QState cncState_jumpEnd(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::jump::jumpEnd} */
        case Q_ENTRY_SIG: {
            print("END jump\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::jump::jumpEnd::X_SERVO_PAUSE, Y_SERVO_PAUSE, HE~} */
        case X_SERVO_PAUSE_SIG: /* intentionally fall through */
        case Y_SERVO_PAUSE_SIG: /* intentionally fall through */
        case HELPER_PAUSE_SIG: {
            /*${CNC::cncState::SM::jump::jumpEnd::X_SERVO_PAUSE, Y~::[xServoPaused()&&yServoPaused()&~} */
            if (xServoPaused() && yServoPaused() && xyHelperPaused()) {
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::jump::jumpEnd::HELPER_EVENT} */
        case HELPER_EVENT_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_jump);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::needleDown} .........................................*/
QState cncState_needleDown(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::needleDown::Q_INIT} */
        case Q_INIT_SIG: {
            RresetBreak();
            osDelay(100);
            startVfd(1);
            armTimer(2000, &stateYieldEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::needleDown::SENSOR_DOWN} */
        case SENSOR_DOWN_SIG: {
            RsetBreak();
            disArmTimer();
            status_ = Q_TRAN(&cncState_idle);
            break;
        }
        /*${CNC::cncState::SM::needleDown::SENSOR_CLT_OUT,SENSOR_ZERO} */
        case SENSOR_CLT_OUT_SIG: /* intentionally fall through */
        case SENSOR_ZERO_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::needleDown::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            startVfd(0);
            status_ = Q_TRAN(&cncState_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::ioTestMode} .........................................*/
QState cncState_ioTestMode(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::ioTestMode} */
        case Q_ENTRY_SIG: {
            print("enter Io test state\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::ioTestMode} */
        case Q_EXIT_SIG: {
            print("exit Io test state\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::ioTestMode::Q_INIT} */
        case Q_INIT_SIG: {
            armTimer(100, (void*)&nextStateEvt);
            //unlatchStartSig();
            print("IO test mode\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::ioTestMode::EXIT_TEST_STATE} */
        case EXIT_TEST_STATE_SIG: {
            unlatchQuiltSig();
            armTimer(2000, (void*)&testDoneEvt);

            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::ioTestMode::TEST_DONE} */
        case TEST_DONE_SIG: {
            status_ = Q_TRAN(&cncState_idle);
            break;
        }
        /*${CNC::cncState::SM::ioTestMode::SET_BREAK_COM} */
        case SET_BREAK_COM_SIG: {
            setBreak();
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::ioTestMode::RESET_BREAK_COM} */
        case RESET_BREAK_COM_SIG: {
            resetBreak();
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::ioTestMode::SET_VALVE_COM} */
        case SET_VALVE_COM_SIG: {
            machineTestEvt_t *ev = (machineTestEvt_t*)e;
            setValve(ev->valve);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::ioTestMode::RESET_VALVE_COM} */
        case RESET_VALVE_COM_SIG: {
            machineTestEvt_t *ev = (machineTestEvt_t*)e;
            resetValve(ev->valve);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::ioTestMode::QUILT_TEST} */
        case QUILT_TEST_SIG: {
            if (readQuiltSig())
                unlatchQuiltSig();
            else
                latchQuiltSig();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::ntop} ...............................................*/
QState cncState_ntop(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::ntop::Q_INIT} */
        case Q_INIT_SIG: {
            resetBreak();
            startVfd(1);
            armTimer(2000, &nextStateEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::ntop::SENSOR_TOP} */
        case SENSOR_TOP_SIG: {
            cncInsUn_t tIns;
            uint8_t peak = peakNextIns(&tIns);
            uint8_t insType = tIns.type;
            /*${CNC::cncState::SM::ntop::SENSOR_TOP::[peak&&insType!=STITCH_INS&&insT~} */
            if (peak &&
                insType != STITCH_INS &&
                 insType != ZERO_INS)
            {
                setBreak();
                disArmTimer();
                return gotoNextInsState(me);
                status_ = Q_HANDLED();
            }
            /*${CNC::cncState::SM::ntop::SENSOR_TOP::[!peak]} */
            else if (!peak) {
                disArmTimer();
                EXIT_ERR("peak fail in NTOP\n");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::ntop::SENSOR_CLT_OUT} */
        case SENSOR_CLT_OUT_SIG: {
            cncInsUn_t tIns;
            uint8_t peak = peakNextIns(&tIns);
            uint8_t insType = tIns.type;
            /*${CNC::cncState::SM::ntop::SENSOR_CLT_OUT::[peak&&insType==STITCH_INS||insT~} */
            if (peak &&
                insType == STITCH_INS ||
                 insType == ZERO_INS)
            {
                disArmTimer();
                /*${CNC::cncState::SM::ntop::SENSOR_CLT_OUT::[peak&&insType==~::[insType==ZERO_INS]} */
                if (insType == ZERO_INS) {
                    status_ = Q_TRAN(&cncState_zero);
                }
                /*${CNC::cncState::SM::ntop::SENSOR_CLT_OUT::[peak&&insType==~::[insType==STITCH_INS]} */
                else if (insType == STITCH_INS) {
                    status_ = Q_TRAN(&cncState_stitch);
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::ntop::SENSOR_CLT_OUT::[!peak]} */
            else if (!peak) {
                disArmTimer();
                EXIT_ERR("peak fail in NTOP\n");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::ntop::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            EXIT_ERR("timeout in NTOP\n");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::moveServo} ..........................................*/
QState cncState_moveServo(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::moveServo::HELPER_EVENT} */
        case HELPER_EVENT_SIG: {
            int cont = moveSerovCont();
            /*${CNC::cncState::SM::moveServo::HELPER_EVENT::[!cont]} */
            if (!cont) {
                terminateJump();
                status_ = Q_TRAN(&cncState_exitMove);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::moveServo::Q_INIT} */
        case Q_INIT_SIG: {
            uint8_t i;
            print("start move\n");

            for (i = 0; i < 3; i++)
            {
                if (moveSerovCont() == 0)
                {
                    if (i > 1)
                    {
                        armTimer(150, &testDoneEvt);
                        terminateJump();
                    }
                    else
                    {
                        postStateYield();
                    }
                }
            }

            if (i == 3)
                armTimer(150, &nextStateEvt);

            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::moveServo::NEXT_STATE} */
        case NEXT_STATE_SIG: {
            helperTigger();
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::moveServo::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            status_ = Q_TRAN(&cncState_idle);
            break;
        }
        /*${CNC::cncState::SM::moveServo::TEST_DONE} */
        case TEST_DONE_SIG: {
            helperTigger();
            status_ = Q_TRAN(&cncState_exitMove);
            break;
        }
        /*${CNC::cncState::SM::moveServo::X_SERVO_INT_ERROR, Y_SERVO_INT_E~} */
        case X_SERVO_INT_ERROR_SIG: /* intentionally fall through */
        case Y_SERVO_INT_ERROR_SIG: {
            exitIdleState();

            if (e->sig == Y_SERVO_INT_ERROR_SIG)
            EXIT_ERR("Y servo INT ERROR\n");
            else if (e->sig == X_SERVO_INT_ERROR_SIG)
            EXIT_ERR("X servo INT ERROR\n");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::moveServo::exitMove} ................................*/
QState cncState_exitMove(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::moveServo::exitMove::X_SERVO_PAUSE, Y_SERVO_PAUSE, HE~} */
        case X_SERVO_PAUSE_SIG: /* intentionally fall through */
        case Y_SERVO_PAUSE_SIG: /* intentionally fall through */
        case HELPER_PAUSE_SIG: {
            /*${CNC::cncState::SM::moveServo::exitMove::X_SERVO_PAUSE, Y~::[xServoPaused()&&yServoPaused()&~} */
            if (xServoPaused() && yServoPaused() && xyHelperPaused()) {
                status_ = Q_TRAN(&cncState_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::moveServo::exitMove::HELPER_EVENT} */
        case HELPER_EVENT_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_moveServo);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::errorState} .........................................*/
QState cncState_errorState(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::errorState} */
        case Q_ENTRY_SIG: {
            print("feed error\n");
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::errorState::NEXT_STATE, STOP} */
        case NEXT_STATE_SIG: /* intentionally fall through */
        case STOP_SIG: {

            uint8_t stop = !readQuiltSig();
            armTimer(2000, &nextStateEvt);

            /*${CNC::cncState::SM::errorState::NEXT_STATE, STOP::[stop]} */
            if (stop) {
                disArmTimer();
                status_ = Q_TRAN(&cncState_idle);
            }
            /*${CNC::cncState::SM::errorState::NEXT_STATE, STOP::[!stop]} */
            else if (!stop) {
                unlatchQuiltSig();
                stopFeederv2();
                print("fail to stop feeder form ERR_STATE\n");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::errorState::Q_INIT} */
        case Q_INIT_SIG: {
            resetServoTask();
            unlatchQuiltSig();
            stopFeederv2();
            armTimer(2000, &nextStateEvt);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::stopingState} .......................................*/
QState cncState_stopingState(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::stopingState::NEXT_STATE} */
        case NEXT_STATE_SIG: {
            uint8_t stop = !readQuiltSig();
            /*${CNC::cncState::SM::stopingState::NEXT_STATE::[stop]} */
            if (stop) {
                print("quilt stoped\n");
                status_ = Q_TRAN(&cncState_idle);
            }
            /*${CNC::cncState::SM::stopingState::NEXT_STATE::[!stop]} */
            else if (!stop) {
                EXIT_ERR("fail to stop quilt STOPINGSTATE\n");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::stopingState::Q_INIT} */
        case Q_INIT_SIG: {
            unlatchQuiltSig();
            stopFeederv2();
            armTimer(500, &nextStateEvt);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::errorExitStitch} ....................................*/
QState cncState_errorExitStitch(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::errorExitStitch::Q_INIT} */
        case Q_INIT_SIG: {
            gpCount = 0;

            cncInsUn_t tIns;
            tIns.type = STITCH_INS;
            tIns.cncIns.id = 0xEEEEEEEE;
            tIns.stitchIns.stepTime = 30 * 1000 * 72;
            tIns.stitchIns.xStep = 0;
            tIns.stitchIns.yStep = 300;
            tIns.stitchIns.vfdSpeed = 1;

            makeStitch(&tIns.stitchIns);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::errorExitStitch::SENSOR_CLT_OUT} */
        case SENSOR_CLT_OUT_SIG: {
            gpCount++;

            if (!servoTrigger())
                EXIT_ERR("fail to triger servo from ERR_STITCH\n");


            /*${CNC::cncState::SM::errorExitStitch::SENSOR_CLT_OUT::[gpCount>=4]} */
            if (gpCount >= 4) {
                status_ = Q_TRAN(&cncState_errorStitchStop);
            }
            /*${CNC::cncState::SM::errorExitStitch::SENSOR_CLT_OUT::[gpCount<4]} */
            else if (gpCount < 4) {
                cncInsUn_t tIns;
                tIns.type = STITCH_INS;
                tIns.cncIns.id = 0xEEEEEEEE;
                tIns.stitchIns.stepTime = 30 * 1000 * 72;
                tIns.stitchIns.xStep = 0;
                tIns.stitchIns.yStep = 300;
                tIns.stitchIns.vfdSpeed = 1;

                makeStitch(&tIns.stitchIns);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::errorExitStitch::errorStitchStop} ...................*/
QState cncState_errorStitchStop(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::errorExitStitch::errorStitchStop::X_SERVO_PAUSE, Y_SERVO_PAUSE} */
        case X_SERVO_PAUSE_SIG: /* intentionally fall through */
        case Y_SERVO_PAUSE_SIG: {
            /*${CNC::cncState::SM::errorExitStitch::errorStitchStop::X_SERVO_PAUSE, Y~::[!(TIM3->CR1&TIM_CR1_CEN)&&!(TIM~} */
            if (!(TIM3->CR1 & TIM_CR1_CEN) && !(TIM4->CR1 & TIM_CR1_CEN) && isBreakSet()) {
                EXIT_ERR("exit from err stitch\n");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::errorExitStitch::errorStitchStop::SENSOR_TOP} */
        case SENSOR_TOP_SIG: {
            setBreak();
            /*${CNC::cncState::SM::errorExitStitch::errorStitchStop::SENSOR_TOP::[!(TIM3->CR1&TIM_CR1_CEN)&&!(TIM~} */
            if (!(TIM3->CR1 & TIM_CR1_CEN) && !(TIM4->CR1 & TIM_CR1_CEN) && isBreakSet()) {
                EXIT_ERR("exit from err stitch\n");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&cncState_errorExitStitch);
            break;
        }
    }
    return status_;
}

/*${CNC::cncState::SM::SIM_run} ............................................*/
QState cncState_SIM_run(cncState * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${CNC::cncState::SM::SIM_run} */
        case Q_EXIT_SIG: {
            print("exit SIM_run\n");
            stopFeederv2();
            simUnlat();
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::SIM_run::Q_INIT} */
        case Q_INIT_SIG: {
            print("SIM runnign\n");
            runFeeder();
            armTimer(2000, &stateYieldEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::SIM_run::SIM_STOP} */
        case SIM_STOP_SIG: {
            status_ = Q_TRAN(&cncState_idle);
            break;
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::SIM_run::NEXT_STATE} */
        case NEXT_STATE_SIG: {

            int run = simReadQuiltSig();
            /*${CNC::cncState::SM::SIM_run::NEXT_STATE::[run]} */
            if (run) {
                int peak = peakNextIns(&insTemp);
                /*${CNC::cncState::SM::SIM_run::NEXT_STATE::[run]::[peak]} */
                if (peak) {
                    getNextIns(&insTemp);
                    simProcessIns(&insTemp);
                    status_ = Q_HANDLED();
                }
                /*${CNC::cncState::SM::SIM_run::NEXT_STATE::[run]::[!peak]} */
                else if (!peak) {
                    print("peakFail\n");
                    status_ = Q_TRAN(&cncState_idle);
                    break;
                    status_ = Q_HANDLED();
                }
                else {
                    status_ = Q_UNHANDLED();
                }
            }
            /*${CNC::cncState::SM::SIM_run::NEXT_STATE::[!run]} */
            else if (!run) {
                status_ = Q_TRAN(&cncState_idle);
                break;
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${CNC::cncState::SM::SIM_run::STATE_YIELD} */
        case STATE_YIELD_SIG: {
            print("timeout for QULT_RUN_SIG\n");
            status_ = Q_TRAN(&cncState_idle);
            break;
            status_ = Q_HANDLED();
            break;
        }
        /*${CNC::cncState::SM::SIM_run::QUILT_RUN} */
        case QUILT_RUN_SIG: {
            disArmTimer();
            postEvent(&nextStateEvt);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${CNC::cncState} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
