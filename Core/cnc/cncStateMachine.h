/*$file${../cnc_muc/Core/~::cncStateMachine.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: model.qm
* File:  ${../cnc_muc/Core/~::cncStateMachine.h}
*
* This code has been generated by QM 5.2.1 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${../cnc_muc/Core/~::cncStateMachine.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*
 * cncStateMachineDef.h
 *
 *  Created on: Aug 24, 2022
 *      Author: sanjay
 */

#ifndef INC_CNCSTATEMACHINEDEF_H_
#define INC_CNCSTATEMACHINEDEF_H_

#include "servoDef.h"
#include "qpc.h"
#include "cnc.h"


#ifdef __cplusplus
extern "C" {
#endif



enum sensorSig
{
    SENSOR_TOP_SIG = 0x201,
    SENSOR_DOWN_SIG,
    SENSOR_HOOK_SIG,
    SENSOR_CLT_OUT_SIG,
    SENSOR_ZERO_SIG,
};

enum machineCommandSig
{
    START_SIG = 0x301,
    QUILT_RUN_SIG,
    START_0_SIG,
    STOP_SIG,

    SIM_START_SIG,
    SIM_STOP_SIG,

    SET_RETAINER_POS_SIG,
    SET_NEEDLE_DOWN_POS_SIG,
    SET_NEEDLE_TOP_POS_SIG,
    SET_LOOP_POS_SIG,
    TEST_SERVO_SIG,
    MOVE_SEROV_SIG,

    SET_BREAK_COM_SIG,
    RESET_BREAK_COM_SIG,
    TOGGLE_BREAK_COM_SIG,

    SET_VALVE_COM_SIG,
    RESET_VALVE_COM_SIG,
    TOGGLE_VALVE_COM_SIG,

    RESET_BREAK_SIG,

    TEST_JUMP_SIG,

    QUILT_TEST_SIG,

    IO_TEST_MODE_SIG,
    EXIT_TEST_STATE_SIG,

    CTRL_REG_SIG,

    X_SERVO_INT_ERROR_SIG,
    Y_SERVO_INT_ERROR_SIG,

};



enum stateMachineSig
{
    TEST_DONE_SIG = 0x401,
    NEXT_STATE_SIG,
    GP_TIGGER_SIG,
    STATE_YIELD_SIG,
    STATE_TEST_SIG,
};

/*============== ask QM to declare the Blinky class ================*/
/*$declare${CNC::cncState} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${CNC::cncState} .........................................................*/
typedef struct {
/* protected: */
    QActive super;

/* public: */
    QTimeEvt timeEvt;
} cncState;

/* protected: */
QState cncState_initial(cncState * const me, void const * const par);
QState cncState_idle(cncState * const me, QEvt const * const e);
QState cncState_needleTop(cncState * const me, QEvt const * const e);
QState cncState_needleLoop(cncState * const me, QEvt const * const e);
QState cncState_testServo(cncState * const me, QEvt const * const e);
QState cncState_zero(cncState * const me, QEvt const * const e);
QState cncState_zeroRunning(cncState * const me, QEvt const * const e);
QState cncState_zeroStoping(cncState * const me, QEvt const * const e);
QState cncState_zeroLastStitch(cncState * const me, QEvt const * const e);
QState cncState_zeroChangeOver(cncState * const me, QEvt const * const e);
QState cncState_stitch(cncState * const me, QEvt const * const e);
QState cncState_stitchRunning(cncState * const me, QEvt const * const e);
QState cncState_lastStitch(cncState * const me, QEvt const * const e);
QState cncState_stitchStoping(cncState * const me, QEvt const * const e);
QState cncState_stitchChangeOver(cncState * const me, QEvt const * const e);
QState cncState_valve(cncState * const me, QEvt const * const e);
QState cncState_halt(cncState * const me, QEvt const * const e);
QState cncState_jump(cncState * const me, QEvt const * const e);
QState cncState_jumpEnd(cncState * const me, QEvt const * const e);
QState cncState_needleDown(cncState * const me, QEvt const * const e);
QState cncState_ioTestMode(cncState * const me, QEvt const * const e);
QState cncState_ntop(cncState * const me, QEvt const * const e);
QState cncState_moveServo(cncState * const me, QEvt const * const e);
QState cncState_exitMove(cncState * const me, QEvt const * const e);
QState cncState_errorState(cncState * const me, QEvt const * const e);
QState cncState_stopingState(cncState * const me, QEvt const * const e);
QState cncState_errorExitStitch(cncState * const me, QEvt const * const e);
QState cncState_errorStitchStop(cncState * const me, QEvt const * const e);
QState cncState_SIM_run(cncState * const me, QEvt const * const e);
/*$enddecl${CNC::cncState} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

extern const QEvt testDoneEvt;
extern const QEvt nextStateEvt;
extern const QEvt stateYieldEvt;
extern const QEvt stateTestEvt;
extern const QEvt qInitEvt;


void postEvent(const void *ev);
void postEventISR(const void *ev);
void startStateMachine();



int simReadQuiltSig();
void simUnlat();
void simProcessIns(cncInsUn_t *ins);


#ifdef __cplusplus
}
#endif





#endif /* INC_CNCSTATEMACHINEDEF_H_ */

